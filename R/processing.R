
# These functions are used for data processing and analytics

#' Load single cell RNA-seq data from directory or file
#' 
#' @param dir A string - directory path generated by 10xGenomics pipeline. Default value is \code{NULL}.
#' @param file A string - file path of single cell RNA-Seq count matrix. Default value is \code{NULL}. If both \code{dir} and \code{file} are provided. Only the former will be used.
#' @param gcol An integer - the column index of gene names in the 10xGenomics directory. Default value is \code{2}.
#' @param org A string - name of organism. Currently only "human" or "mouse" are accepted. Default value is \code{"human"}.
#' @param cc A logcial value - if cell cycle scores are calculated. Default value is \code{TRUE}.
#' @param ... Additional arguments to be passed to the function \code{\link{CreateSeuratObject}}.
#' 
#' @return A Seurat of object.
#' 
#' @importFrom Seurat Read10X CreateSeuratObject PercentageFeatureSet CellCycleScoring
#' @importFrom utils read.table
#' @export
#' 

load_scfile <- function(dir = NULL, gcol = 2, org = "human", cc = T, file = NULL, ...) {
        
        if (is.null(dir) + is.null(file) == 0) warning("Both directory and file are provided. Only the former was used.", call. = F, immediate. = T)  
  
        if (!is.null(dir))  {
                mtx <- Read10X(data.dir = dir, gene.column = gcol)
        } else {
                mtx <- read.table(file = file, sep = "\t", header = T, check.names = F)
        }
        
        data <- CreateSeuratObject(counts = mtx, ...)
        
        mito_pattern <- ifelse(org == 'human', "^MT-", "^mt-")
        data[["percent.mt"]] <- PercentageFeatureSet(data, pattern = mito_pattern)
        
        if (org == "mouse") {
                
                s.genes <- vlookup(cc.genes$s.genes, mm_hs, 2, 1)
                g2m.genes <- vlookup(cc.genes$g2m.genes, mm_hs, 2, 1)
                
                s.genes <- s.genes[!is.na(s.genes)]
                g2m.genes <- g2m.genes[!is.na(g2m.genes)]
                
        } else {
                
                s.genes <- cc.genes$s.genes
                g2m.genes <- cc.genes$g2m.genes
        }
        
        if (cc) data <- CellCycleScoring(data, s.features = s.genes, g2m.features = g2m.genes, set.ident = TRUE)
        
        data$group <- data@project.name
        
        return(data)
}

#' Filter and normalize Seurat object
#' 
#' @param dataset A Seurat object.
#' @param range_nFeature An integer vector - the range of nFeature_RNA for filtering. Default value is \code{c(500, Inf)}. 
#' @param range_nCount An integer vector - the range of nCount_RNA for filtering. Default value is \code{c(500, Inf)}.
#' @param range_mt An numeric vector - the range of percent.mt for filtering. Default value is \code{c(-Inf, 10)}.
#' 
#' @return A Seurat object.
#' @importFrom Seurat FetchData NormalizeData FindVariableFeatures
#' @importFrom purrr map
#' @importFrom magrittr %>% %<>%
#' @export
#' 

filter_norm_scdata <- function(dataset, 
                              range_nFeature = c(500, Inf), range_nCount = c(500, Inf), range_mt = c(-Inf, 10)) {
        
        expr <- purrr::map(.x = c("nFeature_RNA", "nCount_RNA", "percent.mt"), .f = Seurat::FetchData, object = dataset)
        
        dataset <- dataset[, which(x = expr[[1]] >= range_nFeature[1] & expr[[1]] <= range_nFeature[2] &
                                      expr[[2]] >= range_nCount[1] & expr[[2]] <= range_nCount[2] &
                                     expr[[3]] >= range_mt[1] & expr[[3]] <= range_mt[2])]
        
        dataset %<>%
                NormalizeData() %>%
                FindVariableFeatures()
        
        return(dataset)
}

filter_sctrans_10X <- function(dataset, nfeature = 500, mito = 10, 
                               vars = c("percent.mt","nCount_RNA","S.Score","G2M.Score")) {
        
        expr1 <- FetchData(dataset, vars = "nFeature_RNA")
        expr2 <- FetchData(dataset, vars = "percent.mt")
        
        dataset <- dataset[, which(x = expr1 > nfeature & expr2 < mito)]
        dataset %<>% 
                SCTransform(vars.to.regress = vars, verbose = T)
        
}

find_doublets <- function(dataset, dims = 1:20, ratio = 0.05, resolution = 0.4, txt) {
        
        dataset %<>%
                ScaleData(vars.to.regress = c("percent.mt","nCount_RNA","S.Score","G2M.Score"), verbose = T) %>%
                RunPCA(features = VariableFeatures(dataset)) %>%
                RunUMAP(dims = dims) %>%
                FindNeighbors(dims = dims) %>%
                FindClusters(resolution = resolution)
        
        ## pK Identification
        sweep.res <- paramSweep_v3(dataset, PCs = dims)
        sweep.stats <- summarizeSweep(sweep.res, GT = FALSE)
        bcmvn <- find.pK(sweep.stats)
        
        ## Homotypic Doublet Proportion Estimate
        homotypic.prop <- modelHomotypic(dataset$seurat_clusters)
        nExp_poi <- round(ratio*length(Idents(dataset)))
        nExp_poi.adj <- round(nExp_poi*(1-homotypic.prop))
        
        dataset <- doubletFinder_v3(dataset, PCs = dims, pN = 0.25, pK = 0.1, nExp = nExp_poi.adj, reuse.pANN = F)
        
        barcodes <- names(dataset@active.ident)[dataset[[paste("DF.classifications_0.25_0.1_", as.character(nExp_poi.adj), sep = "")]] == "Doublet"]
        
        paste(barcodes, txt, sep = "")
        
}

#' Streamlined analysis of Seurat object after integration
#' 
#' @param dataset A Seurat object.
#' @param group.levels A string vector - factor levels of biological samples. 
#' @param verbose A logical value -  
#' @param npcs An integer - 
#' @param reduction A string -
#' @param dims An integer vector -
#' @param nnei An integer -
#' @param min.dist A double -
#' @param spread A double -
#' @param n.epochs An integer -
#' @param k.param An integer -
#' @param resolution A double -
#' 
#' @return A Seurat object.
#' @importFrom Seurat RunPCA RunUMAP FindNeighbors FindClusters
#' @importFrom magrittr %>% %<>%
#' @export
#' 

analyze_merged <- function(dataset, group.levels,
                           verbose = T, npcs = 50,
                           reduction = "umap", dims = 1:20, nnei = 30, min.dist = 0.3, spread = 1, n.epochs = 500, 
                           k.param = 20,
                           resolution = 0.8) {
        
        dataset$group <- factor(dataset$group, levels = group.levels)
        dataset %<>% 
                RunPCA(npcs = npcs, verbose = verbose) %>%
                RunUMAP(reduction = "pca", dims = dims, n.neighbors = nnei, min.dist = min.dist, spread = spread, n.epochs = n.epochs) %>%
                FindNeighbors(reduction = reduction, dims = 1:2, k.param = k.param) %>%
                FindClusters(resolution = resolution, algorithm = 3)
        
}


#' Rename clusters in Seurat object
#' 
#' @param dataset A Seurat object.
#' @param labels An string vector - new names of each cluster. 
#' 
#' @return A Seurat object.
#' @importFrom Seurat Idents
#' @importFrom plyr mapvalues
#' @export
#' 

rename_cluster <- function(dataset, labels) {
        
        if (length(labels) != length(levels(Idents(dataset)))) {
                stop("Length of new names must be the same with old names.")
        } else {
                current.name <- levels(Idents(dataset))
                new.name <- labels
                
                Idents(dataset) <- plyr::mapvalues(x = Idents(dataset), from = current.name, to = new.name)
                return(dataset)
        }
}

#' Find differential expressed genes between two groups in each cluster
#' 
#' @param dataset A Seurat object.
#' @param clusters A string vector - clusters to investigate.
#' @param groups A string vector -
#' @param logfc A double -
#' 
#' @return A Seurat object.
#' @importFrom Seurat Idents FindMarkers
#' @importFrom tibble add_column as_tibble
#' @importFrom magrittr %>% %<>%
#' @export
#' 

find_diff_genes <- function(dataset, clusters, groups, logfc = 0.25) {
        
        dataset$celltype.group <- paste(Idents(object = dataset), dataset$group, sep = "_")
        Idents(object = dataset) <- "celltype.group"
        
        
        de <- list()
        
        for (i in seq(length(clusters))) {
                
                d <- FindMarkers(dataset, 
                                  ident.1 = paste(clusters[i], groups[2], sep = "_"),
                                  ident.2 = paste(clusters[i], groups[1], sep = "_"),
                                  logfc.threshold = logfc,
                                  assay = "RNA")
                d %<>%
                        add_column(feature = rownames(d), .before = 1) %>%
                        add_column(cluster = clusters[i], .after = 1)
                
                de[[i]] <- as_tibble(d)
        }
        
        de <- do.call("rbind", de)
        
        de

}

#' GSEA analysis of differential gene expression in each cluster
#' 
#' @param diff A tibble -
#' @param clusters A string vector - clusters to investigate.
#' @param pathway A vector list - group of gene lists 
#' 
#' @return A Seurat object.
#' @importFrom Seurat Idents FindMarkers
#' @importFrom dplyr filter right_join distinct arrange desc
#' @importFrom tidyr replace_na
#' @importFrom tibble add_column as_tibble
#' @importFrom magrittr %>% %<>%
#' @importFrom fgsea fgsea
#' @export
#' 

test_GSEA <- function(diff, clusters, pathway) {
        
        gsea_res <- list()
        
        for (i in seq(length(clusters))) {
                
                data <- diff %>%
                        filter(cluster == clusters[i]) %>%
                        right_join(mm_hs, by = c("feature" = "mouse")) %>%
                        replace_na(list(avg_logFC = 0)) %>%
                        distinct(human, .keep_all = T) %>%
                        arrange(desc(avg_logFC))
                
                l <- data$avg_logFC
                names(l) <- data$human
                
                res <- fgsea(pathways = pathway, l, minSize = 15, maxSize = 500, nperm = 100000)
                
                res %<>%
                        add_column(cluster = clusters[i], .before = 1)
                
                gsea_res[[i]] <- res
        }
        
        gsea_res <- do.call("rbind", gsea_res)
        
        return(as_tibble(gsea_res))
        
}

#' Add gene program scores
#' 
#' @param dataset A Seurat object.
#' @param features An string vector - a gene list of expression programs. 
#' @param org A string - name of organism. Currently only "human" or "mouse" are accepted. 
#' @param nbin An integer - number of bins of aggregate expression levels for all analyzed features
#' @param ctrl An integer - number of control features selected from the same bin per analyzed feature
#' @param name A string - name of the expression program
#' 
#' @return A Seurat object.
#' @importFrom Seurat AddModuleScore
#' @export
#' 

add_program_score <- function(dataset, features, org = "human", nbin = 20, ctrl = 10, name){
  
        if(org == "mouse"){
                prog_genes <- vlookup(features, mm_hs, 2, 1)
                prog_genes <- list(prog_genes[!is.na(prog_genes)])
        } else {
                prog_genes <- list(features)
        }
        
        n_genes <- nrow(dataset@assays$integrated@scale.data)
        
        genes_per_bin <- round(n_genes/nbin)
  
        ctrl <- ifelse(ctrl > genes_per_bin, round(genes_per_bin/3), ctrl)
  
        dataset <- AddModuleScore(dataset,
                                  features = prog_genes,
                                  ctrl = ctrl,
                                  nbin = nbin,
                                  name = name)
  
        return(dataset)
}


seurat_to_monocle <- function(dataset, subset = F, clusters = NULL) {
        
        dataset$cluster <- Idents(dataset)
        
        data <- GetAssayData(dataset, assay = 'RNA', slot = 'counts')
        pd <- new('AnnotatedDataFrame', data = dataset@meta.data)
        fd <- new('AnnotatedDataFrame', 
                      data = data.frame(gene_short_name = row.names(data), row.names = rownames(data)))
        
        cds <- newCellDataSet(data,
                                  phenoData = pd,
                                  featureData = fd,
                                  lowerDetectionLimit = 0.5,
                                  expressionFamily = negbinomial.size())
        cds %<>% 
                estimateSizeFactors() %>%
                estimateDispersions() %>%
                detectGenes(min_expr = 0.1)
        
        if (subset) {
                cds <- cds[,row.names(subset(pData(cds), cluster %in% clusters))]
        }
        
        return(cds)

}

analyze_monocle <- function(cds, rev = F) {
        
        expressed_genes <- row.names(subset(fData(cds), num_cells_expressed >= 10))
        
        diff_test_res <- differentialGeneTest(cds[expressed_genes,], fullModelFormulaStr = "~group")
        
        ordering_genes <- row.names(subset(diff_test_res, qval < 10E-70))
        
        cds %<>% 
                setOrderingFilter(ordering_genes) %>%
                reduceDimension(max_components = 2, method = 'DDRTree') %>%
                orderCells(reverse = rev)
        
        return(cds)

}



